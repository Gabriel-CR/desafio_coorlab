/*!
 * vue-observable v0.1.4
 * (c) 2019 Jakub Juszczak
 * Released under the MIT License.
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.VueObservable = global.VueObservable || {})));
}(this, (function (exports) { 'use strict';

var Intersect = {
  name: 'intersect',
  abstract: true,
  props: {
    /**
     * A specific ancestor of the target element being observed.
     * If no value was passed to the constructor or this is null, the
     * top-level document's viewport is used.
     * @url: https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/root
     */
    root: {
      default: function () { return null; }
    },
    /**
     * An offset rectangle applied to the root's bounding box when
     * calculating intersections, effectively shrinking or growing the
     * root for calculation purposes. The value returned by this property
     * may not be the same as the one specified when calling the constructor
     * as it may be changed to match internal requirements. Each offset can be
     * expressed in pixels (px) or as a percentage (%).
     * The default is "0px 0px 0px 0px".
     * @url: https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/rootMargin
     */
    rootMargin: {
      type: String,
      default: function () { return '0px 0px 0px 0px'; }
    },
    /**
     * A list of thresholds, sorted in increasing numeric order, where each threshold
     * is a ratio of intersection area to bounding box area of an observed target. Notifications
     * for a target are generated when any of the thresholds are crossed for that target. If no value
     * was passed to the constructor, 0 is used.
     * @url: https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/thresholds
     */
    threshold: {
      type: Array,
      default: function () { return [0, 0.2]; }
    }
  },
  data: function data () {
    return {
      _observer: null
    }
  },
  created: function created () {
    var this$1 = this;

    if ('IntersectionObserver' in window) {
      this.$data._observer = new IntersectionObserver(function (entries) { // eslint-disable-line no-undef
        if (!entries[0].isIntersecting) {
          this$1.$emit('leave', [entries[0]]);
        } else {
          this$1.$emit('enter', [entries[0]]);
        }
        this$1.$emit('change', [entries[0]]);
      }, {
        threshold: this.threshold,
        root: this.root,
        rootMargin: this.rootMargin
      });
    } else {
      console.warn('[✋ VueObservables] You need to polyfill IntersectionObserver');
    }
  },
  mounted: function mounted () {
    var this$1 = this;

    this.$nextTick(function () {
      if (this$1.$slots.default && this$1.$slots.default.length > 1) {
        console.warn('[✋ VueObservables] You may only wrap one element in a <intersect> component.');
      } else if (!this$1.$slots.default || this$1.$slots.default.length < 1) {
        console.warn('[✋ VueObservables] You must have one child inside a <intersect> component.');
        return
      }
      this$1.$data._observer.observe(this$1.$slots.default[0].elm);
    });
  },
  destroyed: function destroyed () {
    this.$data._observer.disconnect();
  },
  render: function render () {
    return this.$slots.default ? this.$slots.default[0] : null
  }
};

var Mutation = {
  name: 'mutate',
  abstract: true,
  props: {
    /**
     * Set to true if additions and removals of the target
     * node's child elements (including text nodes) are to be observed.
     */
    childList: {
      type: Boolean,
      default: true
    },
    /**
     * Set to true if mutations to target's data are to be observed.
     */
    characterData: {
      type: Boolean,
      default: true
    },
    /**
     * Set to true if mutations to target's attributes are to be observed.
     */
    attributes: {
      type: Boolean,
      default: true
    },
    /**
     * Set to true if mutations to target and target's descendants
     * are to be observed.
     */
    subtree: {
      type: Boolean,
      default: true
    },
    /**
     * Set to true if attributes is set to true and
     * target's attribute value before the mutation needs to be recorded.
     */
    attributeOldValue: {
      type: Boolean,
      default: false
    },
    /**
     * Set to true if characterData is set to true and target's data
     * before the mutation needs to be recorded.
     */
    characterDataOldValue: {
      type: Boolean,
      default: false
    },
    /**
     * Set to an array of attribute local names
     * (without namespace) if not all attribute mutations need to be observed.
     */
    attributeFilter: {
      type: Array,
      default: function () { return []; }
    }
  },
  data: function data () {
    return {
      _observer: null
    }
  },
  created: function created () {
    var this$1 = this;

    if ('MutationObserver' in window) {
      this.$data._observer = new MutationObserver(function (mutations) { // eslint-disable-line no-undef
        mutations.forEach(function (mutation) {
          this$1.$emit('mutation', [mutation]);
        });
      });
    } else {
      console.warn('[✋ VueObservables] You need to polyfill MutationObserver');
    }
  },
  mounted: function mounted () {
    var this$1 = this;

    this.$nextTick(function () {
      if (this$1.$slots.default && this$1.$slots.default.length > 1) {
        console.warn('[✋ VueObservables] You may only wrap one element in a <muatate> component.');
      } else if (!this$1.$slots.default || this$1.$slots.default.length < 1) {
        console.warn('[✋ VueObservables] You must have one child inside a <mutate> component.');
        return
      }
      this$1.$data._observer.observe(this$1.$slots.default[0].elm, this$1.$props);
    });
  },
  destroyed: function destroyed () {
    this.$data._observer.disconnect();
  },
  render: function render () {
    return this.$slots.default ? this.$slots.default[0] : null
  }
};

var Resize = {
  name: 'resize',
  abstract: true,
  props: {

  },
  data: function data () {
    return {
      _observer: null
    }
  },
  created: function created () {
    var this$1 = this;

    if ('ResizeObserver' in window) {
      this.$data._observer = new ResizeObserver(function (entries) { // eslint-disable-line no-undef
        this$1.$emit('resize', [entries[0]]);
      });
    } else {
      console.warn('[✋ VueObservables] You need to polyfill ResizeObserver');
    }
  },
  mounted: function mounted () {
    var this$1 = this;

    this.$nextTick(function () {
      if (this$1.$slots.default && this$1.$slots.default.length > 1) {
        console.warn('[✋ VueObservables] You may only wrap one element in a <resize> component.');
      } else if (!this$1.$slots.default || this$1.$slots.default.length < 1) {
        console.warn('[✋ VueObservables] You must have one child inside a <resize> component.');
        return
      }
      this$1.$data._observer.observe(this$1.$slots.default[0].elm);
    });
  },
  destroyed: function destroyed () {
    this.$data._observer.disconnect();
  },
  render: function render () {
    return this.$slots.default ? this.$slots.default[0] : null
  }
};

function plugin(Vue) {
  Vue.component('intersect', Intersect);
  Vue.component('mutate', Mutation);
  Vue.component('resize', Resize);
}

// Install by default if using the script tag
if (typeof window !== 'undefined' && window.Vue) {
  window.Vue.use(plugin);
}

var version = '0.1.4';

exports['default'] = plugin;
exports.Intersect = Intersect;
exports.Mutation = Mutation;
exports.Resize = Resize;
exports.version = version;

Object.defineProperty(exports, '__esModule', { value: true });

})));
